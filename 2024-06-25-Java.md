---
layout:     post
title:      Java
subtitle:   Java的基础
date:       2024-06-25
author:     KAI
header-img: img/wallhaven-l8vp7y.jpg
catalog: true
tags:
    - Java
    - 面试
---

## Java事务管理

事务的ACID属性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)

-  A（原子性）事务的原子操作单元，对数据的修改，要么全部执行，要么全部不执行； 

-  C（一致性）在事务开始和完成时，数据必须保持一致状态，相关的数据规则必须应用于事务的修改，以保证数据的完整性，事务结束时，所有的内部数据结构必须正确； 

-  I（隔离性）保证事务不受外部并发操作影响的独立环境执行； 

-  D（持久性）事务完成之后，对于数据的修改是永久的，即使系统出现故障也能够保持；

  事务分为声明式事务和编程事务

  声明事务是通过配置方式来管理事务，编程事务通过编写代码显式地管理事务的开始、提交和回滚。（比较少用）

#### 1.1 JDBC事务

JDBC的一切行为包括事务是基于一个Connection的，JDBC通过Connection对象进行事务管理。

常用的事物相关方法是：setAutoCommit    commit    rollback等

JDBC事务的优点： 接口较为简单，性能较好 缺点： 不支持多[数据库](https://cloud.tencent.com/solution/database?from_column=20065&from=20065)的事务

### spring声明事务实现

开启声明事务用的是`@Transactional` ，本质上是使用的 代理和AOP来实现。

1. **创建代理对象**：Spring容器启动，检查配置的事务管理器和使用@Transactional的注解的Bean，然后生成一个代理对象

2. **动态织入事务管理逻辑**：在代理对象中，当这个@Transactional注解所标识的方法被调用时会被代理对象拦截

   然后前后织入事务管理逻辑。这些逻辑包括开启事务、方法执行、提交事务或回滚事务等。

3. **事务边界控制**：当客户端调用被@Transactional注解标识的方法时，实际上是调用了代理对象的方法。代理对象在方法执行前会启动事务，在方法执行后根据方法执行情况决定是提交事务还是回滚事务。

4. **事务传播行为**：Spring事务管理器支持不同的事务传播行为，例如REQUIRED、REQUIRES_NEW、NESTED等。Spring AOP会根据@Transactional注解中设置的事务传播行为来决定是否需要创建新的事务，以及如何处理嵌套事务。

总的来说，Spring AOP通过动态代理技术，在方法调用前后织入事务管理逻辑，从而实现了对事务的管理。这种方式使得开发者无需手动编写事务管理代码，大大简化了事务管理的工作

### @Transactional 注解的参数

#### rollbackFor：捕获到异常就回滚事务

~~~java
@Transactional(rollbackFor = Exception.class}
~~~

#### propagation (事务传播行为)

事务的传播行为是指：当前事务方法被调用的时候，需要做什么样的操作

<img src="C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240417105332416.png" alt="image-20240417105332416" style="zoom: 67%;" />

#### isolation（事务隔离级别）

数据库隔离级别

![image-20240417105309091](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240417105309091.png)

### @Transactional 实践

A事务的定义如下不会改变，B事务的传播行为可能会变。

~~~java
@Transactional(rollbackFor = Exception.class)
public void A() {
    userMapper.insertUser("A",1);
    sqlTestService.B();
}

public void B() {
    userMapper.insertUser("B",2);
}
~~~

##### 嵌套事务

修改B事务的传播行为，让它生成嵌套事务

~~~java
@Transactional(rollbackFor = Exception.class, propagation = Propagation.NESTED)
~~~

**嵌套事务和父事务是有关联的，当A事务回滚的时候，B事务一定回滚。**

**当B事务异常回滚的时候，要判断在A里面是否try了B事务，如果try就A不会回滚，只是B回滚。**

##### 新事务

修改B事务的传播行为，让它生成新事务

~~~java
@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)
~~~

A、B事务没有什么必然的关系

##### 当前事务

修改B事务的传播行为，让它加入当前事务

~~~java
@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)

@Transactional(rollbackFor = Exception.class, propagation = Propagation.SUPPORTS)
~~~

A、B方法都是一起提交、或一起回滚。

## Java主流ORM框架

ORM 是 Object Relational Mapping 的缩写，译为 “对象关系映射” 框架。

ORM 框架就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述 Java 对象与数据库表之间的映射关系，自动将 Java 应用程序中的对象持久化到关系型数据库的表中。

程序员使用 API 直接操作 JavaBean 对象就可以实现数据的存储、查询、更改和删除等操作。

<img src="http://c.biancheng.net/uploads/allimg/200714/1-200G415225NI.gif" alt="img" style="zoom: 67%;" />

常见的框架有 Hibernate 和 MyBatis

MyBatis 框架是一个半自动映射的框架。这里所谓的 “半自动” 是相对于 Hibernate 框架全表映射而言的，MyBatis 框架需要手动匹配提供 POJO、SQL 和映射关系，而 Hibernate 框架只需提供 POJO 和映射关系即可。

## Java基础

#### [JVM](https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm)

Java 虚拟机（JVM）是运行 Java 字节码（即.class文件）的虚拟机。一次编译，随处可以运行

![运行在 Java 虚拟机之上的编程语言](https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png)

JIT为编译器把文件编译过一次就会保存下来机器码，后面再运行时效率就会提高

![Java程序转变为机器代码的过程](https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png)

### 基本类型和包装类型

基本类型包括：

1. 整型：byte, short, int, long
2. 浮点型：float, double
3. 字符型：char
4. 布尔型：boolean

包装类型

1. 整型：Byte, Short, Integer, Long
2. 浮点型：Float, Double
3. 字符型：Character
4. 布尔型：Boolean

包装类型主要用于集合类（如`ArrayList`、`LinkedList`等）和泛型中，**因为这些类只能存储对象，无法存储基本类型。**

- **默认值**：**成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。**

**基本数据类型存放在栈中是一个常见的误区。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。** 

### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能.

例如 Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，

**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**

例如

Integer i1 = 40; 相当于Integer i1=Integer.valueOf(40)
Integer i2 = new Integer(40); 相当于新创建一个对象
System.out.println(i1==i2);  结果为false；

~~~java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static {
        // high value may be configured by property
        int h = 127;
    }
}
~~~

`Float`,`Double` 并没有实现缓存机制。如果超出对应范围仍然会去创建新的对象

### 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

并且频繁的拆装箱会损害系统性能

下面就是拆装箱的示例

~~~java
Integer i = 10;  //装箱 等价于Integer i = Integer.valueOf(10)
int n = i;   //拆箱 等价于int n = i.intValue()
~~~

### 如何解决浮点数运算的精度丢失问题

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。

### 静态变量

静态变量也就是被 `static` 关键字修饰的变量。**它可以被类的所有实例共享**，无论一个类创建了多少个对象，它们都共享同一份静态变量。

静态变量是通过类名来访问的，例如`StaticVariableExample.staticVar`（如果被 `private`关键字修饰就无法这样访问了）。

### 字符常量和字符串常量

字符常量只占 2 个字节; 字符串常量占若干个字节。

字符常量相当于一个整型值( ASCII 值),可以参加表达式运算;

 字符串常量代表一个地址值(该字符串在内存中存放位置)

### 静态方法为什么不能调用非静态成员

1.静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。**而非静态成员属于实例对象，只有在对象实例化之后才存在**，需要通过类的实例对象去访问。

2.在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

静态方法调用无需创建对象，实例则不行。但是实例可以访问静态成员和实例成员

### 重载和重写的区别

重载

发生在同一个类中（或者父类和子类之间），==方法名必须相同==，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

#### [重写](#重写)

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类(方法的权限不能比父类低)
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

## 面向对象基础

创建对象的运算符

new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）

### 面向对象三大特征

#### 抽象

就是将一个真实的对象映射成程序中的对象，模拟它的特定行为和属性即可

#### 封装

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，而仅向程序其他部分暴露有限的接口的能力。

#### 继承

子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。

子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

子类可以用自己的方式实现父类的方法。

#### 多态

多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

多态是指程序能够检测对象所属的实际类，并在当前上下文 不知道其真实类型的情况下调用其实现的能力

~~~Java
// 父类 Animal
class Animal {
    public void makeSound() {
        System.out.println("动物发出声音");
    }
}

// 子类 Dog
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("狗叫：汪汪汪");
    }
}

// 子类 Cat
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("猫叫：喵喵喵");
    }
}

public class Main {
    public static void main(String[] args) {
        // 使用多态
        Animal animal1 = new Dog(); // Dog 对象
        Animal animal2 = new Cat(); // Cat 对象
        
        animal1.makeSound(); // 调用 Dog 类的 makeSound() 方法
        animal2.makeSound(); // 调用 Cat 类的 makeSound() 方法
    }
}

~~~

### 深拷贝和浅拷贝

1. **浅拷贝（Shallow Copy）**：
   - 浅拷贝创建一个新对象{==会在堆上创建一个新的对象，区别于引用拷贝的一点==}，然后将原始对象的非静态字段的值复制到新对象中。如果字段是基本类型，那么就会复制其值；如果字段是引用类型，则复制引用，而不是引用的对象本身。因此，新对象和原始对象共享相同的引用对象。
   - **修改新对象中的引用对象**会影响到原始对象中相应的引用对象，因为它们指向同一块内存地址。
2. **深拷贝（Deep Copy）**：
   - 深拷贝创建一个新对象，并且递归地将原始对象的所有字段以及其引用的对象都复制到新对象中。这意味着新对象和原始对象是完全独立的，对新对象的修改不会影响到原始对象，反之亦然。
   - 在深拷贝中，即使字段是引用类型，也会复制引用的对象本身，而不仅仅是引用。

![浅拷贝、深拷贝、引用拷贝示意图](https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png)

### Object

Object 类是一个特殊的类，是所有类的父类

#### ==和equals的区别

- 对于基本数据类型来说，`==` 比较的是值
- 对于引用数据类型来说，`==` 比较的是对象的内存地址
- 所有类都有equals方法

equals无法判断基本数据类型，只能比较对象是否相等

~~~java
public boolean equals(Object obj) {
     return (this == obj);
}
~~~

- 如果没有重写的话，相当于用==去比较
- 重写一般是去比较它们的属性

`String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

#### hashCode()的作用

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这哈希码值的主要作用是用于支持哈希表这样的数据结构。

`hashCode()` 定义在 JDK 的 `Object` 类中，意味着 Java 中的任何类都包含有 `hashCode()` 函数。

当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

#### 重写 equals() 时也要重写 hashCode() 方法

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 

`equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

#### 接口和抽象类的共同点和区别

共同点:

- 都不能实例化
- 都可以有抽象方法

区别：

- 一个类只能继承一个父类，可以继承多个接口
- 接口主要用来规定类的行为方法，抽象类则用来代码复用和强调所属关系
- 接口的成员变量是public static final，不能修改。抽象类的成员变量默认default可以在子类中重新定义或赋值

### String

#### String、StringBuffer、StringBuilder 的区别？

由可变性，安全性和性能方面去解释

**`String` 是不可变的，所以是线程安全的**

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，

在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，可以用append（）可以修改字符串

`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

stringBuffer是安全的,通过 synchronized 关键字修饰

性能方面

**每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象**。

但使用StringBuilder要承担多线程不安全的风险

**使用场景**

String：少量数据

`StringBuilder` ：单线程操作字符串缓缓冲区下大量数据

StringBuffer：多线程下操作字符串缓冲区大量数据

#### String为什么不可变

**因为`String` 类中使用 `final` 关键字修饰字符数组**来保存字符串

~~~java
public final class String implements java.io.Serializable {
    private final char value[];
}
~~~

不可变的原因

- 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
- `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

### 字符串拼接用到+

“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

底层实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

### 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。如果要创建的字符串存在，则从池中取出引用

~~~java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
//会在堆中创建一个单独的对象"ab"
String s = new String("ab");
~~~

## 异常

<img src="https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom:50%;" />

Exception和Error区别

**`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。

Exception又分为两类

**Checked Exception** 即 受检查异常 和**Unchecked Exception** (不受检查异常，可以不处理也可以正常通过编译)。

**`Error`**：`Error` 属于程序无法处理的错误，Java 虚拟机（JVM）一般会选择线程终止

#### try-catch-finally

**不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。

## 泛型

编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。

有三种使用方式，泛型类，泛型接口，泛型方法

实例化泛型

~~~
ArrayList<E> extends AbstractList<E>
~~~

## 反射

### 什么是反射

反射是一种在程序运行时动态获取类的信息，操作类的属性和方法的机制，而不需要在编译时确定这些信息

 JDK 实现动态代理的示例代码，其中就使用了反射类 `Method` 来调用指定的方法。

~~~java
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("after method " + method.getName());
        return result;
    }
}
~~~

#### 反射实战

要动态获取信息，先需要依靠class对象（字节码对象）

有四种方式

![image-20240414191006796](C:\Users\86147\AppData\Roaming\Typora\typora-user-images\image-20240414191006796.png)

使用反射操作

~~~java
public class Main {
    public static void main(String[] args)   {
        /**
         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
         */
        Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
        TargetObject targetObject = (TargetObject) targetClass.newInstance();
        /**
         * 获取 TargetObject 类中定义的所有方法
         */
        Method[] methods = targetClass.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        /**
         * 获取指定方法并调用
         */
        Method publicMethod = targetClass.getDeclaredMethod("publicMethod",
                String.class);

        publicMethod.invoke(targetObject, "JavaGuide");

        /**
         * 获取指定参数并对参数进行修改
         */
        Field field = targetClass.getDeclaredField("value");
        //为了对类中的参数进行修改我们取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");

        /**
         * 调用 private 方法
         */
        Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
        //为了调用private方法我们取消安全检查
        privateMethod.setAccessible(true);
        privateMethod.invoke(targetObject);
    }
}
~~~

## 注解

注解本质是一个继承了`Annotation` 的特殊接口

~~~java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {

}
public interface Override extends Annotation{

}
~~~

注解只有被解析之后才会生效，常见的解析方法有两种：

**编译期直接扫描**:@override

**运行期通过反射处理**:像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过反射来进行处理的

## SPI

Service Provider Interface 

专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。

### 和API区别

<img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark.png" alt="img" style="zoom:50%;" />

由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。



## 序列化和反序列化

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

- **序列化**：将数据结构或对象转换成**二进制字节流**的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

Json是一种序列化协议

**JDK自带的序列化方式，只需实现 `java.io.Serializable`接口即可。然后最后手动设置serialVersionUID。**

**在反序列化时，会检查当前类和serialVersionUID是否一致，不一致会抛出异常。**

## I/O

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

Java只有值传递（只会拷贝实参的地址或者实参的值然后创建一个副本），没有引用传递。

这里的值是对象引用

## Java代理模式

代理模式是一种比较好理解的设计模式。简单来说就是 **我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。**

静态代理在实际中应用效果不佳。**静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

~~~java
public class SmsProxy implements SmsService {

    private final SmsService smsService;

    public SmsProxy(SmsService smsService) {
        this.smsService = smsService;
    }
	//重写了send方法，相当于加强了原有目标的功能
    @Override
    public String send(String message) {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("before method send()");
        smsService.send(message);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("after method send()");
        return null;
    }
}

~~~

动态代理

**动态代理是在运行时动态生成类字节码，并加载到 JVM 中的**

#### JDK动态代理机制

**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。

~~~java
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }
/*
loader :类加载器，用于加载代理对象。
interfaces : 被代理类实现的一些接口；
h : 实现了 InvocationHandler 接口的对象
*/
~~~



**通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 

你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

~~~java
public interface InvocationHandler {

    /**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     proxy :动态生成的代理类
	method : 与代理类对象调用的方法相对应
	args : 当前 method 方法的参数
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
~~~

使用步骤

1. 定义一个接口及其实现类；
2. 自定义 `InvocationHandler`（implements InvocationHandler接口） 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象；

### 语法糖

只是方便使用 ，JVM并不支持这些语法糖

只是**在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖**

##### 可变长参数

它允许一个方法把任意数量的值作为参数。

~~~java
 print("Holis", "公众号:Hollis", "博客：www.hollischuang.com", "QQ：907607222");
~~~

##### 内部类

内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，`outer.java`里面定义了一个内部类`inner`，一旦编译成功，就会生成两个完全不同的`.class`文件了，分别是`outer.class`和`outer$inner.class`。所以内部类的名字完全可以和它的外部类名字相同。

lambda 表达式也是语法糖

**lambda 表达式的实现其实是依赖了一些底层的 api，在编译阶段，编译器会把 lambda 表达式进行解糖，转换成调用内部 api 的方式。**

### Unsafe

==TODO 待了解==

Java语言先比较与C和C++有一个非常大的不同点在于Java语言无法直接操作内存，Unsafe提供了通过Java直接操作内存的API。

`Unsafe` 提供的这些功能的实现需要依赖本地方法（Native Method）。

你可以**将本地方法看作是 Java 中使用其他编程语言编写的方法。**

但是使用这个类有很多限制，由`Bootstrap classLoader`加载不会报错。

有两个方案调动

1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 `theUnsafe` 

~~~java
private static Unsafe reflectGetUnsafe() {
    try {
      Field field = Unsafe.class.getDeclaredField("theUnsafe");
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      return null;
    }
}
~~~

## Java集合

Java 集合，也叫作容器，主要是由两大接口派生而来

一个是 `Collection`接口（单列值集合），一个是 `Map` （键值对集合）接口

<img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览" style="zoom: 50%;" />

### [说说 List, Set, Queue, Map 四者的区别？](#说说-list-set-queue-map-四者的区别)

- `List`(对付顺序的好帮手): 存储的元素是有序的、可重复的。
- `Set`(注重独一无二的性质): 存储的元素不可重复的。
- `Queue`(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- `Map`(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表 key，"y" 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### ArrayList 源码分析

`ArrayList` 的底层是数组队列，相当于动态数组，容量可以动态增长，可以存储null值，不过不建议

~~~java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

  }
~~~

`List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。

`RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。

`Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。

`Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。

### Arraylist 与 LinkedList 区别

都不是线程安全的

**底层数据结构：**`ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构

**插入和删除是否受元素位置的影响**：

`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。

`LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。

**LinkerList不支持快速随机访问,因为底层数据结构是双向链表组成，内存空间不连续，不支持随机访问**

**内存空间占用：**

`ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间

### 源码分析

#### 扩容机制

~~~java
/**
 * 默认初始容量大小
 */
private static final int DEFAULT_CAPACITY = 10;

private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

/**
 * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)
 */
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

/**
 * 带初始容量参数的构造函数。（用户自己指定容量）
 */
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {//初始容量大于0
        //创建initialCapacity大小的数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {//初始容量等于0
        //创建空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {//初始容量小于0，抛出异常
        throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
    }
}
/**
 *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
 *如果指定的集合为null，throws NullPointerException。
 */
public ArrayList(Collection<? extends E> c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
~~~

**以无参数构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。**

add方法

~~~java
/**
* 将指定的元素追加到此列表的末尾。
*/
public boolean add(E e) {
    // 加元素之前，先调用ensureCapacityInternal方法
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 这里看到ArrayList添加元素的实质就相当于为数组赋值
    elementData[size++] = e;
    return true;
}
~~~

- 当我们要 `add` 进第 1 个元素到 `ArrayList` 时，`elementData.length` 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 `minCapacity` 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。
- 当 `add` 第 2 个元素时，`minCapacity` 为 2，此时 `elementData.length`(容量)在添加第一个元素后扩容成 `10` 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。
- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。

直到添加第 11 个元素，`minCapacity`(为 11)比 `elementData.length`（为 10）要大。进入 `grow` 方法进行扩容

#### grow方法扩容

minCapacity**为所需的最小容量**

`int newCapacity = oldCapacity + (oldCapacity >> 1)`,所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）

~~~java
/**
 * 要分配的最大数组大小
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
 * ArrayList扩容的核心方法。
 */
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
    int newCapacity = oldCapacity + (oldCapacity >> 1);

    // 然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;

    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);

    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
~~~



当 `add` 第 1 个元素时，`oldCapacity` 为 0，经比较后第一个 if 判断成立，`newCapacity = minCapacity`(为 10)。但是第二个 if 判断不会成立，即 `newCapacity` 不比 `MAX_ARRAY_SIZE` 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，`add` 方法中 return true,size 增为 1。

当 `add` 第 11 个元素进入 `grow` 方法时，`newCapacity` 为 15，比 `minCapacity`（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 huge`C`apacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。

以此类推······

**这里补充一点比较重要，但是容易被忽视掉的知识点：**

- Java 中的 `length`属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.
- Java 中的 `length()` 方法是针对字符串说的,如果想看这个字符串的长度则用到 `length()` 这个方法.
- Java 中的 `size()` 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看

#### hugeCapacity() 方法

从上面 `grow()` 方法源码我们知道：如果新容量大于 `MAX_ARRAY_SIZE`,进入(执行) `hugeCapacity()` 方法来比较 `minCapacity` 和 `MAX_ARRAY_SIZE`，如果 `minCapacity` 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 `MAX_ARRAY_SIZE` 即为 `Integer.MAX_VALUE - 8`。

~~~java
private static int hugeCapacity(int minCapacity) {
    if (minCapacity < 0) // overflow
        throw new OutOfMemoryError();
    // 对minCapacity和MAX_ARRAY_SIZE进行比较
    // 若minCapacity大，将Integer.MAX_VALUE作为新数组的大小
    // 若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小
    // MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    return (minCapacity > MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}

~~~

### [`System.arraycopy()` 和 `Arrays.copyOf()`方法](https://javaguide.cn/java/collection/arraylist-source-code.html#system-arraycopy-和-arrays-copyof-方法)

`ArrayList` 中大量调用了这两个方法，我们上面讲的扩容操作以及`add(int index, E element)`、`toArray()` 等方法中都用到了该方法

#### [`System.arraycopy()` 方法](https://javaguide.cn/java/collection/arraylist-source-code.html#system-arraycopy-方法)

~~~java
    // 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义
    public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
~~~

#### [`Arrays.copyOf()`方法](https://javaguide.cn/java/collection/arraylist-source-code.html#arrays-copyof-方法)

~~~java
    public static int[] copyOf(int[] original, int newLength) {
      // 申请一个新的数组
        int[] copy = new int[newLength];
  // 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
~~~

#### [两者联系和区别](https://javaguide.cn/java/collection/arraylist-source-code.html#两者联系和区别)

`copyOf()`内部实际调用了 `System.arraycopy()` 方法

**区别：**

**`arraycopy()` 需要目标数组**，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 

`copyOf()` 是系统自动在**内部新建一个数组**，并返回该数组。

## LinkedList

### [LinkedList 为什么不能实现 RandomAccess 接口？](#linkedlist-为什么不能实现-randomaccess-接口)

`RandomAccess` 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 `LinkedList` 底层数据结构是链表，**内存地址不连续**，只能通过指针来定位，不支持随机快速访问，所以不能实现 `RandomAccess` 接口。

### 源码分析

~~~java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
  //...
}
~~~

实现一下接口

- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。
- `Deque` ：继承自 `Queue` 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，`Deque` 的发音为 "deck" [dɛk]，这个大部分人都会读错。
- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。
- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。

LinkedList的元素定义

~~~java
private static class Node<E> {
    E item;// 节点值
    Node<E> next; // 指向的下一个节点（后继节点）
    Node<E> prev; // 指向的前一个节点（前驱结点）

    // 初始化参数顺序分别是：前驱结点、本身节点值、后继节点
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
~~~

### [初始化](https://javaguide.cn/java/collection/linkedlist-source-code.html#初始化)

`LinkedList` 中有一个无参构造函数和一个有参构造函数。

~~~java
// 创建一个空的链表对象
public LinkedList() {
}

// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象
public LinkedList(Collection<? extends E> c) {
    this();
    addAll(c);
}
~~~

### [插入元素](https://javaguide.cn/java/collection/linkedlist-source-code.html#插入元素)

`LinkedList` 既可以头插也可以尾插

### [获取元素](#获取元素)

`LinkedList`获取元素相关的方法一共有 3 个：

1. `getFirst()`：获取链表的第一个元素。
2. `getLast()`：获取链表的最后一个元素。
3. `get(int index)`：获取链表指定位置的元素。

`get(int index)` 或 `remove(int index)` 等方法内部都调用了该方法来获取对应的节点。

从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率

### [删除元素](#删除元素)

`LinkedList`删除元素相关的方法一共有 5 个：

1. `removeFirst()`：删除并返回链表的第一个元素。

2. `removeLast()`：删除并返回链表的最后一个元素。

3. `remove(E e)`：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。

4. `remove(int index)`：删除指定索引处的元素，并返回该元素的值。

5. `void clear()`：移除此链表中的所有元素

6. ~~~java
   // 删除链表中首次出现的指定元素，如果不存在该元素则返回 false
   public boolean remove(Object o) {
       // 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除
       if (o == null) {
           for (Node<E> x = first; x != null; x = x.next) {
               if (x.item == null) {
                   unlink(x);
                   return true;
               }
           }
       } else {
           // 如果不为 null ,遍历链表找到要删除的节点
           for (Node<E> x = first; x != null; x = x.next) {
               if (o.equals(x.item)) {
                   unlink(x);
                   return true;
               }
           }
       }
       return false;
   }
   
   ~~~

删除元素的核心在于 `unlink(Node<E> x)` 这个方法：

~~~java
E unlink(Node<E> x) {
    // 断言 x 不为 null
    // assert x != null;
    // 获取当前节点（也就是待删除节点）的元素
    final E element = x.item;
    // 获取当前节点的下一个节点
    final Node<E> next = x.next;
    // 获取当前节点的前一个节点
    final Node<E> prev = x.prev;

    // 如果前一个节点为空，则说明当前节点是头节点
    if (prev == null) {
        // 直接让链表头指向当前节点的下一个节点
        first = next;
    } else { // 如果前一个节点不为空
        // 将前一个节点的 next 指针指向当前节点的下一个节点
        prev.next = next;
        // 将当前节点的 prev 指针置为 null，，方便 GC 回收
        x.prev = null;
    }

    // 如果下一个节点为空，则说明当前节点是尾节点
    if (next == null) {
        // 直接让链表尾指向当前节点的前一个节点
        last = prev;
    } else { // 如果下一个节点不为空
        // 将下一个节点的 prev 指针指向当前节点的前一个节点
        next.prev = prev;
        // 将当前节点的 next 指针置为 null，方便 GC 回收
        x.next = null;
    }

    // 将当前节点元素置为 null，方便 GC 回收
    x.item = null;
    size--;
    modCount++;
    return element;
}
~~~

`unlink()` 方法的逻辑如下：

1. 首先获取待删除节点 x 的前驱和后继节点；
2. 判断待删除节点是否为头节点或尾节点： 
   - 如果 x 是头节点，则将 first 指向 x 的后继节点 next
   - 如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev
   - 如果 x 不是头节点也不是尾节点，执行下一步操作
3. 将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；
4. 将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；
5. 将待删除节点 x 的元素置空，修改链表长度。

### [遍历链表](https://javaguide.cn/java/collection/linkedlist-source-code.html#遍历链表)

推荐使用`for-each` 循环来遍历 `LinkedList` 中的元素， `for-each` 循环最终会转换成迭代器形式

迭代器 `ListItr` 中的核心方法进行详细介绍

这里面的next不是当前节点的next节点，而是下一个要遍历的节点

~~~java
// 双向迭代器
private class ListItr implements ListIterator<E> {
    // 表示上一次调用 next() 或 previous() 方法时经过的节点；
    private Node<E> lastReturned;
    // 表示下一个要遍历的节点；
    private Node<E> next;
    // 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；
    private int nextIndex;
    // 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。
    private int expectedModCount = modCount;
}
~~~

下面是从头到尾方向的迭代

~~~java
// 判断还有没有下一个节点
public boolean hasNext() {
    // 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历
    return nextIndex < size;
}
// 获取下一个节点
public E next() {
    // 检查在迭代过程中链表是否被修改过
    checkForComodification();
    // 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常
    if (!hasNext())
        throw new NoSuchElementException();
    // 将 lastReturned 指向当前节点
    lastReturned = next;
    // 将 next 指向下一个节点
    next = next.next;
    nextIndex++;
    return lastReturned.item;
}
~~~

如果需要删除或插入元素，也可以使用迭代器进行操作。

#### RandomAccess 接口

~~~java
public interface RandomAccess {
}
~~~

==这个接口什么都没有实现，只是一个标识，用来标识这个类有随机访问的能力==

### Set

无序性：不等于随机性，是根据对象的hashcode值来进行决定

不可重复性：指添加的元素按照 `equals()` 判断时 ，返回 false，需要同时重写 `equals()` 方法和 `hashCode()` 方法。

以确保相等的对象具有相等的哈希码，并且哈希码相等的对象也必须根据`equals()`方法判断为相等

#### Comparable 和 Comparator 的区别

`Comparable` 接口和 `Comparator` 接口都是 Java 中用于排序的接口

`Comparable` 接口实际上是出自`java.lang`包 它有一个 **compareTo(Object obj)**方法用来排序

`Comparator`接口实际上是出自 `java.util` 包它有一个**compare(Object obj1, Object obj2)**方法用来排序

~~~java
Comparator 定制排序
Collections.sort(arrayList, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
});

~~~

#### 重写 compareTo 方法实现按年龄来排序

~~~java
// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了
public  class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    /**
     * T重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) {
        if (this.age > o.getAge()) {
            return 1;
        }
        if (this.age < o.getAge()) {
            return -1;
        }
        return 0;
    }
}
~~~

###  HashSet、LinkedHashSet 和 TreeSet 三者的异同

都不是线程安全的，并且元素唯一

`HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。

### Queue

#### Queue 与 Deque 的区别

- `Queue` 扩展了 `Collection` 的接口，根据 **因为容量问题而导致操作失败后处理方式的不同** 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。
- `Deque` 扩展了 `Queue` 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：
- `Deque` 是双端队列，在队列的两端均可以插入或删除元素。
- 事实上，`Deque` 还提供有 `push()` 和 `pop()` 等其他方法，可用于模拟栈。

### [ArrayDeque 与 LinkedList 的区别](#arraydeque-与-linkedlist-的区别)

`ArrayDeque` 和 `LinkedList` 都实现了 `Deque` 接口，两者都具有队列的功能，但两者有什么区别呢？

- `ArrayDeque` 是**基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。**
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好。此外，`ArrayDeque` 也可以用于实现栈。

#### PriorityQueue

1. `PriorityQueue` 利用了==二叉堆的数据结构来实现的==，==底层使用可变长的数组来存储数据==
2. `PriorityQueue` 通过堆元素的上浮和下沉，实现了==在 O(logn) 的时间复杂度内插入元素和删除堆顶元素===。
3. `PriorityQueue` 是非线程安全的，且不支持存储 `NULL` 和 `non-comparable` 的对象。
4. ==`PriorityQueue` 默认是小顶堆==

### BlockingQueue

`BlockingQueue` （阻塞队列）是一个接口，继承自 `Queue`。`BlockingQueue`阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入

常用阻塞队列

ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue

### ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别

它们都是线程安全的

区别：

1. 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
2. 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
3. 锁是否分离： `ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
4. 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。这意味着，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

### ArrayBlockingQueue 源码分析

阻塞队列思想

​	阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 `put`、`take`、`offer`、`poll` 等 API 即可实现多线程之间的生产和消费。

![ArrayBlockingQueue 类图](https://oss.javaguide.cn/github/javaguide/java/collection/arrayblockingqueue-class-diagram.png)

它通过 `AbstractCollection` 获得了集合的常见操作方法，然后通过 `Queue` 接口获得了队列的特性。

#### 核心构造方法

~~~java
// capacity 表示队列初始容量，fair 表示 锁的公平性
public ArrayBlockingQueue(int capacity, boolean fair) {
  //如果设置的队列大小小于0，则直接抛出IllegalArgumentException
  if (capacity <= 0)
      throw new IllegalArgumentException();
  //初始化一个数组用于存放队列的元素
  this.items = new Object[capacity];
  //创建阻塞队列流程控制的锁
  lock = new ReentrantLock(fair);
  //用lock锁创建两个条件控制队列生产和消费
  notEmpty = lock.newCondition();
  notFull =  lock.newCondition();
}
~~~

默认使用非公平锁，即各个生产者或者消费者线程收到通知后，对于锁的争抢是随机的。

阻塞式获取和新增元素方法：

阻塞式就是在进行操作时判断的notEmpty和notFull锁的状态是否符合。

`put(E e)`：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。

`take()` ：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。

#### put方法源码：

~~~java
public void put(E e) throws InterruptedException {
    //确保插入的元素不为null
    checkNotNull(e);
    //加锁
    //消费和生产用的是同一把锁
    final ReentrantLock lock = this.lock;
    //这里使用lockInterruptibly()方法而不是lock()方法是为了能够响应中断操作，如果在等待获取锁的过程中被打断则该方法会抛出InterruptedException异常。
    lock.lockInterruptibly();
    try {
            //如果count等数组长度则说明队列已满，当前线程将被挂起放到AQS队列中，等待队列非满时插入（非满条件）。
       //在等待期间，锁会被释放，其他线程可以继续对队列进行操作。
        while (count == items.length)
            notFull.await();
           //如果队列可以存放元素，则调用enqueue将元素入队
        enqueue(e);
    } finally {
        //释放锁
        lock.unlock();
    }
}
~~~

~~~java
private void enqueue(E x) {
   //获取队列底层的数组
    final Object[] items = this.items;
    //将putindex位置的值设置为我们传入的x
    items[putIndex] = x;
    //更新putindex，如果putindex等于数组长度，则更新为0
    if (++putIndex == items.length)
        putIndex = 0;
    //队列长度+1
    count++;
    //通知队列非空，那些因为获取元素而阻塞的线程可以继续工作了
    notEmpty.signal();
}
~~~

执行步骤为

1. 获取 `ArrayBlockingQueue` 底层的数组 `items`。
2. 将元素存到 `putIndex` 位置。
3. 更新 `putIndex` 到下一个位置，如果 `putIndex` 等于队列长度，则说明 `putIndex` 已经到达数组末尾了，下一次插入则需要 0 开始。(`ArrayBlockingQueue` 用到了循环队列的思想，即从头到尾循环复用一个数组)
4. 更新 `count` 的值，表示当前队列长度+1。
5. 调用 `notEmpty.signal()` 通知队列非空，消费者可以从队列中获取值了。

非阻塞式获取和新增

1. `offer(E e)`：将元素插入队列尾部。如果队列已满，则该方法会直接返回 false，不会等待并阻塞线程。
2. `poll()`：获取并移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。
3. `add(E e)`：将元素插入队列尾部。如果队列已满则会抛出 `IllegalStateException` 异常，底层基于 `offer(E e)` 方法。
4. `remove()`：移除队列头部的元素，如果队列为空则会抛出 `NoSuchElementException` 异常，底层基于 `poll()`。
5. `peek()`：获取但不移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。

### 相关面试题目

#### ArrayBlockingQueue是什么，特点是什么

`ArrayBlockingQueue` 是 `BlockingQueue` 接口的有界队列实现类，常用于多线程之间的数据共享，底层采用数组实现。

==`ArrayBlockingQueue` 的容量有限，一旦创建，容量不能改变。==

为了保证线程安全，`ArrayBlockingQueue` 的并发控制采用可重入锁 `ReentrantLock` ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。并且，它还支持公平和非公平两种方式的锁访问机制，默认是非公平锁。

`ArrayBlockingQueue` 虽名为阻塞队列，但也支持非阻塞获取和新增元素（例如 `poll()` 和 `offer(E e)` 方法），==只是队列满时添加元素会抛出异常，队列为空时获取的元素为 null==

#### ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？

底层数据结构不一样，是否拥有边界界限

锁是否分离：`ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。

内存占用不一样

#### ArrayBlockingQueue 的实现原理

1. `ArrayBlockingQueue` 内部维护一个定长的数组用于存储元素。
2. 通过使用 `ReentrantLock` 锁对象对读写操作进行同步，即通过锁机制来实现线程安全。
3. 通过 `Condition` 实现线程间的等待和唤醒操作。



### Map

### HashMap和Hashtable的区别

线程安全性：

- HashMap是不安全的
- Hashtable` 内部的方法基本都经过`synchronized修饰。


Null key 和 Null value支持：

- ​	HashMap支持，但HashTable会抛异常

**初始容量大小和每次扩充容量大小的不同**：

- HashMap默认大小为16，扩容策略为2倍。如果不使用默认大小容量，`HashMap` 会将其扩充为 2 的幂次方大小
- HashTable是11，默认扩容是2n+1

这个方法保证了大小为2的幂次方。先将cap-1。

然后除了最高位的1之外，所有的位都被设置为1，最后加一返回就变成了2的幂次方了

~~~java
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

~~~

**底层数据结构：**

 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间

### 和TreeMap的区别

基于红黑树数据结构的属性实现的，红黑树保持平衡状态，从而保证了搜索操作的时间复杂度为 O(log n)

**相比于`HashMap`来说， `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

### HashSet如何查重

在 JDK1.8 中，`HashSet`的`add()`方法只是简单的调用了**HashMap**的`put()`方法，并且判断了一下返回值以确保是否有重复元素。

~~~java
// Returns: true if this set did not already contain the specified element
// 返回值：当 set 中没有包含 add 的元素时返回真
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
}
~~~

JDK1.8 中，实际上无论`HashSet`中是否已经存在了某元素，`HashSet`都会直接插入，只是会在`add()`方法的返回值处告诉我们插入前是否存在相同元素。

### HashMap底层实现

JDK1.8 之前 `HashMap` 底层是 **数组和链表** ，得到key的hash值

然后通过 `(n - 1) & hash` 判断当前元素存放的位置。（n 指的是数组的长度，因为n等于2的幂次方，所以n为111...）

 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方，采用&方式比较快

jdk1.8的底层，当链表长度大于8时就会转换成红黑树

![jdk1.8之后的内部结构-HashMap](https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png)

多线程下建议不要使用hashMap来操作数据，可能会出现覆盖数据的问题。并发环境下，推荐使用 `ConcurrentHashMap` 

**举个例子**

两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突。

当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。

随后，线程 1 获得时间片，之前进行过 hash 碰撞的判断，此时会直接进行插入，

这就导致数据覆盖了。

还有一种情况是这两个线程同时 `put` 操作导致 `size` 的值不正确，进而导致数据覆盖的问题：

1. 线程 1 执行 `if(++size > threshold)` 判断时，假设获得 `size` 的值为 10，由于时间片耗尽挂起。

2. 线程 2 也执行 `if(++size > threshold)` 判断，获得 `size` 的值也为 10，并将元素插入到该桶位中，并将 `size` 的值更新为 11。

3. 随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。

4. 线程 1、2 都执行了一次 `put` 操作，但是 `size` 的值只增加了 1，也就导致实际上只有一个元素被添加到了 `HashMap` 中

   ~~~java
   public V put(K key, V value) {
       return putVal(hash(key), key, value, false, true);
   }
   
   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                      boolean evict) {
       // ...
       // 实际大小大于阈值则扩容
       if (++size > threshold)
           resize();
       // 插入后回调
       afterNodeInsertion(evict);
       return null;
   }
   ~~~

### ConcurrentHashMap 和 Hashtable 的区别

底层数据结构：

ConcurrentHashMap 是数组加链表和红黑树，Hashtable 则是数组加链表

**实现线程安全的方式（重要）**

- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。

  当一个线程访问同步方法时，其他线程也访问同步方法，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

#### ConcurrentHashMap线程安全具体实现

#### JDK1.8以前

![Java7 ConcurrentHashMap 存储结构](https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png)

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**，

分段数组加链表

`Segment` 的个数一旦初始化就不能改变。默认大小为16可以同时支持 16 个线程并发写。

当访问一段数组的时候，要先获取segment锁，不同的分段数组可以并发执行。

#### JDK1.8 之后

![Java8 ConcurrentHashMap 存储结构](https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png)

`ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。1.7没有红黑树

**`synchronized` 只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。

锁粒度更细并且并发度更大，并发度是整个Node数组的大小

CAS操作：

- CAS是Compare And Swap的缩写，即比较与交换，通常指的==是一种原子操作==，它用于解决多线程并发访问共享数据时的线程安全问题。
- CAS操作包含三个操作数：需要修改的内存位置V、预期原值A和新值B。当且仅当预期原值与内存位置的当前值相同时，才会将内存位置的值修改为新值；否则，CAS操作会失败，并返回内存位置的当前值。

## Java并发面试

### 进程和线程的区别

定义：

- 进程是程序执行的实例，基本单位。
- 线程是线程执行中的一个单元，cpu调度和执行的基本单位

资源拥有：

- 进程由独立的内存空间
- 线程共享一个进程的内存空间和资源

切换成本：

- 进程：切换进程的开销比较大，涉及到上下文的切换，需要保存和恢复更多的状态信息。
- 线程：切换线程的开销相对较小，因为线程共享了同一个进程的地址空间，上下文切换只涉及到线程的私有数据。

并发性：

- 进程：进程之间相互独立，通信和同步需要使用进程间通信（IPC）机制，如管道、信号、消息队列等
- 线程：通过共享内存信息来实现通信

### sleep和wait的区别

使用对象：

- sleep为thread类的方法，线程对象可以直接调用，并且sleep不会释放资源
- wait是object类的方法，只能在同步方法或同步代码块中使用，wait会释放对象锁

用途:

- sleep让线程休眠一段时间
- wait主要用于线程间的通信写作

唤醒方式：

- sleep到点自动唤醒，或者被其他线程中断时会抛出 `InterruptedException` 异常而被唤醒。
- wait要其他线程调用`notify()` 或 `notifyAll()` 方法，或等待超时时限

### run方法和start方法区别

- run方法会在当前线程的调用栈上执行，不会启动新的线程
- start方法会创建一个新的线程并执行run方法

### 用户线程和内核线程区别

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。
- 内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）

用户线程和内核线程的区别和特点：用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

### 线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

![常见的三种线程模型](https://oss.javaguide.cn/github/javaguide/java/concurrent/three-types-of-thread-models.png)

**Java线程采用的是一对一的线程模型**

### java内存区域

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）" style="zoom: 67%;" />

### JVM中的堆和栈

堆：用来存储创建的对象实例和数组，内存是由垃圾收集器（Garbage Collector, GC）来管理的，GC 定期扫描堆内存，回收不再使用的对象，释放内存空间。回收的标准是没有任何对象引用这个对象，那么就会被回收了，而且堆是线程共享的

栈：用来存储方法调用的局部变量，方法参数和方法调用的上下文。局部变量是一些基本数据类型的变量和对象的引用（但不是对象本身）。由JVM自动分配和释放，每次方法调用都会压入一个栈帧，方法执行完后，栈帧自动销毁。每个线程都有自身的栈内存，互相独立的。

| 特性           | 堆（Heap）                           | 栈（Stack）                                    |
| -------------- | ------------------------------------ | ---------------------------------------------- |
| 存储内容       | 对象实例和数组                       | 局部变量和方法调用上下文信息                   |
| 内存管理       | 垃圾收集器自动管理                   | JVM 自动分配和释放                             |
| 生命周期       | 对象在不再有引用时，由 GC 回收       | 局部变量在方法结束时被销毁                     |
| 线程关系       | 线程共享                             | 线程独立                                       |
| 存储的数据类型 | 对象和数组                           | 基本数据类型变量和对象引用                     |
| 性能           | 分配和回收速度相对较慢，需要 GC 处理 | 分配和回收速度快，方法调用和返回时自动进行管理 |

**栈帧的格式**

![Java 虚拟机栈](https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png)

#### 程序计数器**、**虚拟机栈和 **本地方法栈**为什么私有

程序计数器用于记录当前线程执行的位置，依次读取指令。程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**

**虚拟机栈：** 每个 Java 方法在执行之前会创建一个栈帧**用于存储局部变量表、操作数栈、常量池引用等信息**。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 堆和方法区定义

堆和方法区是所有线程共享的资源，堆是最大的一块内存，主要用于存放新的创建对象。

方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

异步就是调用发出之后，不用等待结果就可以直接返回

### 为什么使用多线程

- **从计算机底层来说：** 线程可以比作是轻量级的进程，**是程序执行的最小单位**,线程间的切换和调度的成本低。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。

​	**并且可以提高Cpu的使用率**

线程安全需要在多线程环境下保证数据访问的正确性和一致性

#### 线程的类型和任务的性质分为两种

Cpu密集型和IO密集型

### 线程生命周期和状态

有6种状态：运行(Thread.run)，等待(wait)，终止(执行完run后)，初始（Thread.start），超时等待(sleep)，

阻塞（当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。

<img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图" style="zoom:67%;" />

线程的七种状态

1. **新建（New）：** 线程对象被创建但尚未启动时处于这种状态。

2. **就绪（Runnable）：** 当线程对象创建后，调用了start() 方法启动线程，但尚未被调度执行时，线程处于就绪状态。在就绪状态下，线程等待系统资源的分配，一旦获取到CPU时间片，就可以进入运行状态。

3. **运行（Running）：** 线程获得了CPU时间片，开始执行任务，处于运行状态。

4. **阻塞（Blocked）：** 线程在等待某个条件的满足时会被阻塞，例如等待某个I/O操作完成或者等待获取某个锁。在阻塞状态下，线程暂时不会被分配CPU时间片，直到等待的条件得到满足，才能进入就绪状态。

5. **等待（Waiting）：** 线程处于等待状态，**等待其他线程通知或者唤醒**。线程可以调用wait() 方法或者join() 方法进入等待状态。在等待状态下，线程不会占用CPU时间片。

   join是等待被调用线程的结束。

   例如在主线程当中，一个子线程调用了wait，那么主线程就要等待这个子线程结束才能继续执行

6. **超时等待（Timed Waiting）：** 和等待状态类似，但是线程在等待一段指定的时间后会自动唤醒，例如调用了sleep() 方法或者等待某个条件达成一定的超时时间。在超时等待状态下，线程不会占用CPU时间片。

7. **终止（Terminated）：** 线程执行完任务或者出现异常结束时处于终止状态。一旦线程进入终止状态，就不能再被启动或者执行

### 线程上下文切换

线程从占用 CPU 状态中退出的情况：

1.cpu时间片用完

2.主动让出CPU，调用sleep，wait等

3.调用了阻塞类型的系统中断，例如请求IO

4.被结束或终止

线程上下文意味着下次切换回线程是恢复线程的运行现场

### 线程死锁

四个条件

1.互斥条件：资源任意时刻只有一个线程占用

2.不可抢夺

3.循环等待

4.请求与保持：**一个线程因请求资源而阻塞时，对已获得的资源保持不放**。就是占有且等待

#### 预防和避免死锁

破坏死锁条件

**破坏请求与保持条件**：一次性申请所有的资源。

**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

**破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



#### 避免死锁

避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

### sleep和wait方法对比

**共同点**：两者都可以暂停线程的执行。

**区别**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，**需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法**。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。因为object类方法可以使线程种的对象放弃对象锁，而thread类只是让当前线程暂停

如果直接使用Thread.run并不会以多线程执行，只有start是启动多线程

## JMM（Java 内存模型）详解

JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。

**JMM主要用来确保多线程程序的正确性，保证线程之间共享变量的可见性、有序性和一致性**

## 从 CPU 缓存模型说起

 **CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。**

## 指令重排序

简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。

满足下面 2 个条件才能进行：

- 在单线程环境下不能改变程序运行的结果
- 存在数据依赖关系的不允许重排序

有两种情况

**编译器优化重排**：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。

**指令并行重排**：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

### JMM（Java Memory Model）java内存模型

#### JMM如何抽象线程和主内存之间的关系

在 JDK1.2 之前，Java 的内存模型实现总是从 **主存** （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 **本地内存** （比如机器的寄存器）中，而不是直接在主存中进行读写。

**什么是主内存？什么是本地内存？**

**主内存**：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。

**本地内存**：**每个线程都有一个私有的本地内存**，本地内存存储了该线程以读 / 写共享变量的副本

JMM内存模型

<img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" alt="JMM(Java 内存模型)" style="zoom:50%;" />

线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：

1. 线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。
2. 线程 2 到主存中读取对应的共享变量的值。

关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：

- **锁定（lock）**: 作用于主内存中的变量，将他标记为一个线程独享变量。

- **解锁（unlock）**: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。

- **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。

- **load(载入)**：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。

- **use(使用)**：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。

- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

- **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。

- **write（写入）**：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

  **除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：**

  - 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
  - 一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。
  - 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
  - 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
  - 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量

### [Java 内存区域和 JMM 有何区别？](#java-内存区域和-jmm-有何区别)

 **Java 内存区域和内存模型是完全不一样的两个东西**：

- JVM 内存结构和 Java 虚拟机的运行时区域相关，**定义了 JVM 在运行时如何分区存储程序数据**，就比如说堆主要用于存放对象实例。
- **Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范**，其主要目的是为了简化多线程编程，增强程序可移植性的。

### happens-before原则是什么

**逻辑时钟并不度量时间本身，仅区分事件发生的前后顺序，其本质就是定义了一种 happens-before 关系。**

**原则设计思想**

为了对编译器和处理器的约束尽可能少，**只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行**。

**对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。**

**原则定义**

**如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前**。

两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。

**happens-before 原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。**

**原则常见规则**

1. **程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
2. **解锁规则**：解锁 happens-before 于加锁；
3. **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
4. **传递规则**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
5. **线程启动规则**：Thread 对象的 `start()`方法 happens-before 于此线程的每一个动作。

**happen-before和JMM的关系**

![happens-before 与 JMM 的关系](https://oss.javaguide.cn/github/javaguide/java/concurrent/image-20220731084604667.png)

并发编程三个特性

原子性，可见性，有序性

### 总结

- Java 是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。
- CPU 可以通过制定缓存一致协议来解决内存缓存不一致性问题。
- **指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。
- 你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。
- JSR 133 引入了 happens-before 这个概念来描述两个操作之间的内存可见性。

## volatile关键字

### 保证变量的可见性

如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。会强制线程每次都从主内存中读取

<img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取" style="zoom:50%;" />

`volatile` 关键字能保证数据的可见性，**但不能保证数据的原子性**。除了保证数据可见性还可以**防止 JVM 的指令重排序。**

**通过两种机制来保证内存可见性:**

禁止jvm指令的重排序

内存屏障：volatile关键字会在写操作后插入写屏障（Write Barrier），在读操作前插入读屏障（Read Barrier），

写屏障会强制将数据更新到主内存，读屏障会强制从主内存中读取变量

**volatile 关键字禁止指令重排序的效果**

**双重校验锁实现对象单例（线程安全）**：

~~~java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public  static Singleton getUniqueInstance() {
       //先判断对象是否已经实例过，没有实例化过才进入加锁代码
        if (uniqueInstance == null) {
            //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
~~~

 `uniqueInstance = new Singleton();` 这段代码分为三步执行：

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址

但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。

### 悲观锁

**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

### 乐观锁

线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（版本号机制或CAS算法）（`AtomicInteger`、`LongAdder`）就是使用了乐观锁的一种实现方式 **CAS** 实现的。

悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），乐观锁通常多用于写比较少的情况（多读场景，竞争较少）。不过，乐观锁主要针对的对象是单个共享变量

#### **乐观锁实现的CAS有什么问题**

**ABA问题，误认为A值没有被修改过。解决思路是可以加上版本号机制**

JDK 1.5 以后的 `AtomicStampedReference` 类就是用来解决 ABA 问题的，其中的 `compareAndSet()` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**循环时间开销大**

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。一直不成功的话，会增加系统开销。

**只能保证一个共享变量的原子操作**

### synchronized关键字

主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

主要来修饰

1. 实例方法：进入同步代码前要获得 **当前对象实例的锁** 。

2. 静态方法：进入同步代码前要获得 **当前 class 的锁**。**给类加锁，影响的是静态同步方法的访问，**

   这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。

   静态 `synchronized` 方法和非静态 `synchronized` 方法之间的调用不会互斥。对象实例锁和类锁是分开的

3. 代码块：锁指定对象/类

   - `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
   - `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

总结：

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁；
- `synchronized` 关键字加到实例方法上是给对象实例上锁；
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

**构造方法不能使用synchronized 关键字修饰。**，因为构造方法本身是线程安全的。

#### 底层原理

~~~java
//示例代码
//修饰同步代码块
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }
}
//下面是字节码
~~~

![image-20240420122844002](C:\Users\15282\AppData\Roaming\Typora\typora-user-images\image-20240420122844002.png)

**`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。**

字节码中包含一个 `monitorenter` 指令以及两个 `monitorexit` 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。

**在执行`monitorenter`时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。**

<img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-get-lock-code-block.png" alt="执行 monitorenter 获取锁" style="zoom: 67%;" />

只有锁对象拥有者可以在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。

~~~java
//修饰方法
public class SynchronizedDemo2 {
    public synchronized void method() {
        System.out.println("synchronized 方法");
    }
}
~~~

![image-20240420123427010](C:\Users\15282\AppData\Roaming\Typora\typora-user-images\image-20240420123427010.png)

修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，用的是`ACC_SYNCHRONIZED` 标识。该标识指明了该方法是一个同步方法，由JVM来判别标识。

注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

#### `synchronized` 关键字和 `volatile` 关键字的区别

两者是互补的存在

- `volatile` 关键字是线程同步的轻量级实现，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 **`volatile` 关键字只能用于变量**而 `synchronized` 关键字可以修饰方法以及代码块 。
- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

#### ReentrantLock定义

`ReentrantLock` 实现了 `Lock` 接口，是一个可重入且独占式的锁，比synchronized更灵活和强大

ReentrantLock` 里面有一个内部类 `Sync，主要锁的操作在这个类实现。这个类有公平锁和非公平锁两个子类

`ReentrantLock` 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。

~~~java
// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
~~~

### [公平锁和非公平锁有什么区别？](#公平锁和非公平锁有什么区别)

- **公平锁** : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁

### synchronized 和 ReentrantLock 有什么区别？

#### 两者都是可重入锁

**可重入锁** 也叫递归锁，指的是线程可以再次获取自己的内部锁

#### synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

`ReentrantLock` 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成

`ReentrantLock`增加了一些高级功能。

- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来指定是否是公平的。
- **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法

关于 `Condition`接口的补充：

> `Condition`是 JDK1.5 之后才有的，可以实现多路通知功能也就是在一个`Lock`对象中可以创建多个`Condition`实例（即对象监视器），**线程对象可以注册在指定的`Condition`中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用`notify()/notifyAll()`方法进行通知时，被通知的线程是由 JVM 选择的，用`ReentrantLock`类结合`Condition`实例可以实现“选择性通知”** ，而`synchronized`关键字就相当于整个 `Lock` 对象中只有一个`Condition`实例，所有的线程都注册在它一个身上。如果执行`notifyAll()`方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而`Condition`实例的`signalAll()`方法，只会唤醒注册在该`Condition`实例中的所有等待线程。

- **可中断锁**：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 `synchronized` 就属于是不可中断锁。

- **共享锁**：一把锁可以被多个线程同时获得。
- **独占锁**：一把锁只能被一个线程获得。

#### 线程有读锁情况下不能获取写锁

在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。

在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）

### ThreadLocal

**实现每个线程有自身的本地变量。**

#### 原理

从 `Thread`类源代码入手。

~~~java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
~~~

`Thread` 类中有一个 `threadLocals` 和 一个 `inheritableThreadLocals` 变量，都是 `ThreadLocalMap` 类型的变量。

我们可以把 `ThreadLocalMap` 理解为`ThreadLocal` 类实现的定制化的 `HashMap`。

只有当前线程调用 `ThreadLocal` 类的 `set`或`get`方法时才创建它们。

**因为`ThreadLocalMap`是`ThreadLocal`的静态内部类**

**`ThreadLocal`类的`set()`方法**

~~~java
public void set(T value) {
    //获取当前请求的线程
    Thread t = Thread.currentThread();
    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // 将需要存储的值放入到这个哈希表中
        map.set(this, value);
    //这里的this为threadlocal，value为我们设置的数值
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
~~~

**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。**

**每个`Thread`中都具备一个`ThreadLocalMap`，**

**而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**

`ThreadLocalMap`的 key 就是 `ThreadLocal`对象，value 就是 `ThreadLocal` 对象调用`set`方法设置的值。

<img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png" alt="ThreadLocal 数据结构" style="zoom:67%;" />



#### ThreadLocal的内存泄漏

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。

所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。

这样一来value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。`ThreadLocalMap` 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，会清理掉 key 为 null 的记录。使用完 `ThreadLocal`方法后最好手动调用`remove()`方法

### 线程池

线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。

线程池好处

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。还可以控制并发度

#### 创建线程池

**方式一：通过`ThreadPoolExecutor`构造函数来创建（推荐）。**

![通过构造方法实现](https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-BR-2Ub-c.png)

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建。**

![img](https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-new-thread-pool-methods.png)

1. `FixedThreadPool`：固定线程数量的线程池。
2. `SingleThreadExecutor`： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
3. `CachedThreadPool`： 可根据实际情况调整线程数量的线程池。
4. `ScheduledThreadPool`：给定的延迟后运行任务或者定期执行任务的线程池

#### 线程池常见参数

- `corePoolSize` : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- `maximumPoolSize` : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

~~~java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
~~~

#### 饱和策略

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，`ThreadPoolExecutor` 定义一些策略:

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理。这个是默认的
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。

#### 常用的阻塞队列

<img src="https://img-blog.csdnimg.cn/20210327185057427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0htajA1MDExNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 80%;" />

新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

- 容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：

  `FixedThreadPool` 和 `SingleThreadExector` 。

  `FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。

- `SynchronousQueue`（同步队列）：`CachedThreadPool` 。`SynchronousQueue` 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。

- `DelayedWorkQueue`（延迟阻塞队列）：

  `ScheduledThreadPool` 和 `SingleThreadScheduledExecutor` 。

  `DelayedWorkQueue` 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。`DelayedWorkQueue` 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。

#### 处理任务流程

![图解线程池实现原理](https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-pool-principle.png)

#### 如何设定线程池的大小

如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率

有一个简单并且适用面比较广的公式：

- **CPU 密集型任务(N+1)**： N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，

#### 动态修改线程池参数

![img](https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpoolexecutor-methods.png)

格外需要注意的是`corePoolSize`， 程序运行期间的时候，我们调用 `setCorePoolSize()`这个方法的话，线程池会首先判断当前工作线程数是否大于`corePoolSize`，如果大于的话就会回收工作线程。

### [如何设计一个能够根据任务的优先级来执行的线程池？](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#如何设计一个能够根据任务的优先级来执行的线程池)

假如我们需要实现一个优先级任务线程池的话，那可以考虑使用 `PriorityBlockingQueue` （优先级阻塞队列）作为任务队列。这个队列是线程安全的

![ThreadPoolExecutor构造函数](https://oss.javaguide.cn/github/javaguide/java/concurrent/common-parameters-of-threadpool-workqueue.jpg)

要想让 `PriorityBlockingQueue` 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：

1. 提交到线程池的任务实现 `Comparable` 接口，并重写 `compareTo` 方法来指定任务之间的优先级比较规则。
2. 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)

不过，这存在一些风险和问题，比如：

- `PriorityBlockingQueue` 是无界的，可能堆积大量的请求，从而导致 OOM。
- 可能会导致饥饿问题，即低优先级的任务长时间得不到执行。
- 由于需要对队列中的元素进行排序操作以及保证线程安全（并发控制采用的是可重入锁 `ReentrantLock`），因此会降低性能。

对于 OOM 这个问题的解决比较简单粗暴，就是继承`PriorityBlockingQueue` 并重写一下 `offer` 方法(入队)的逻辑，当插入的元素数量超过指定值就返回 false 。

饥饿问题这个可以通过优化设计来解决（比较麻烦），比如等待时间过长的任务会被移除并重新添加到队列中，但是优先级会被提升。

对于性能方面的影响，是没办法避免的，毕竟需要对任务进行排序操作。并且，对于大部分业务场景来说，这点性能影响是可以接受的。

### 简述java线程池的作用和实现方式

**什么是线程池**

就是一种管理和复用线程的机制，通过维护一部分线程来处理接收到的任务。

主要目的是通过减少线程创建和销毁的开销来降低系统资源的损耗，并且提高系统的性能和响应速度，以及控制并发线程的数量。

**线程池优点**

- 提高响应速度：任务到达时可以用已经创建好的线程
- 降低资源消耗：线程的复用和数量控制，减少线程创建和销毁的损耗
- 控制并发度：通过设置线程池的大小和工作队列的大小避免过多的线程导致系统负载过重或者资源竞争问题

**实现方式：**

常用的线程池实现包括**ThreadPoolExecutor**和**ScheduledThreadPoolExecutor**等。

以下是Java线程池的一般实现步骤：

1. **创建线程池：** 使用`Executors`工厂类或者直接创建`ThreadPoolExecutor`或`ScheduledThreadPoolExecutor`实例来创建线程池。
2. **配置线程池参数：** 设置线程池的核心线程数、最大线程数、线程空闲时间、任务队列类型、拒绝策略等参数。
3. **提交任务：** 使用线程池的`execute(Runnable command)`或`submit(Callable<T> task)`方法来提交任务。
4. **执行任务：** 线程池会根据配置的参数和任务队列来执行任务，通常情况下会重用空闲线程并将任务添加到任务队列中。
5. **关闭线程池：** 当不再需要线程池时，可以调用线程池的`shutdown()`或`shutdownNow()`方法来关闭线程池，并释放相关资源。

### 线程池参数

~~~java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(
     int corePoolSize,//线程池的核心线程数量
     int maximumPoolSize,//线程池的最大线程数
    long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
    TimeUnit unit,//时间单位
    BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
    RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) 

~~~

线程池的参数有

核心线程参数：任务队列未满时，可运行的最大线程数

最大线程数：任务队列满了之后，可运行的线程数变为最大线程数

任务队列：运行的线程数到达核心线程数后，用来存放到来的任务

拒绝策略：当任务队列满了之后并且线程数达到最大线程工作数

**AbortPolicy（默认策略）**：

抛出RejectedExecutionException异常，拒绝处理新任务

**DiscardPolicy**：

- 丢弃无法处理的任务，不抛出异常。

**DiscardOldestPolicy**：

- 丢弃任务队列中最旧的未处理任务，然后重新尝试提交新任务

**CallerRunsPolicy**：

- 由调用线程（提交任务的线程）处理该任务。这种策略可以有效地降低向线程池提交任务的速度，从而减缓新任务的提交速度

### 自定义拒绝策略

如果内置的拒绝策略不能满足需求，可以实现自定义的拒绝策略。只需实现 `RejectedExecutionHandler` 接口即可

### Future

当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 `Future` 类获取到耗时任务的执行结果。异步思想的运用，也是多线程中Future模式。

在 Java 中，`Future` 类只是一个泛型接口，位于 `java.util.concurrent` 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：

- 取消任务；
- 判断任务是否被取消;
- 判断任务是否已经执行完成;
- 获取任务执行结果。

简单理解就是：我有一个任务，提交给了 `Future` 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 `Future` 那里直接取出任务执行结果。

#### Callable 和 Future 有什么关系？

可以通过 `FutureTask` 来理解 `Callable` 和 `Future` 之间的关系

`FutureTask` 提供了 `Future` 接口的基本实现，常用来封装 `Callable` 和 `Runnable`，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。`ExecutorService.submit()` 方法返回的其实就是 `Future` 的实现类 `FutureTask` 。

`FutureTask` 还实现了`Runnable` 接口，可以作为任务直接被线程执行。

![img](https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg)

`FutureTask` 有两个构造函数，可传入 `Callable` 或者 `Runnable` 对象。实际上，传入 `Runnable` 对象也会在方法内部转换为`Callable` 对象。

`FutureTask`相当于对`Callable` 进行了封装，管理着任务执行的情况，存储了 `Callable` 的 `call` 方法的任务执行结果。

### CompletableFuture 类有什么用？

![img](https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg)

- Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。
- CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。

### AQS

全称为 `AbstractQueuedSynchronizer` ，抽象队列同步器。**AQS 就是一个抽象类**，**主要用来构建锁和同步器。**

我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。

### 原理

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 **CLH 队列锁** 实现的，即将暂时获取不到锁的线程加入到队列中。

CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列。AQS 是将**每条请求共享资源的线程**封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。

![img](https://oss.javaguide.cn/github/javaguide/java/CLH.png)

AQS中的变量

AQS 使用 **int 成员变量 `state` 表示同步状态**，通过内置的 **线程等待队列** 来完成获取资源线程的排队工作。

`state` 变量由 `volatile` 修饰，用于展示当前临界资源的获锁情况。

~~~java
// 共享变量，使用volatile修饰保证线程可见性
private volatile int state;
~~~

资源状态信息 state 可以通过 protected 类型的getState()、setState()和compareAndSetState() 进行操作。并且，这几个方法都是 final 修饰的，在子类中无法被重写。

以 `ReentrantLock` 为例，`state` 初始值为 0，表示未锁定状态。A 线程 `lock()` 时，会调用 `tryAcquire()` 独占该锁并将 `state+1` 。此后，其他线程再 `tryAcquire()` 时就会失败，直到 A 线程 `unlock()` 到 `state=`0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（`state` 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。

这里为什么能行是因为**state**是一个共享变量 ，是一个资源。

再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，`state` 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后`countDown()` 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 `state=0` )，会 `unpark()` 主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作

### [Semaphore 有什么用？](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#semaphore-有什么用)

`synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，而`Semaphore`(信号量)可以用来控制同时**访问特定资源**的线程数量。

当初始的资源个数为 1 的时候，`Semaphore` 退化为排他锁。

`Semaphore` 有两种模式：。

- **公平模式：** 调用 `acquire()` 方法的顺序就是获取许可证的顺序，遵循 FIFO；
- **非公平模式：** 抢占式的。

下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。

~~~java
// 初始共享资源数量
final Semaphore semaphore = new Semaphore(5);
// 获取1个许可
semaphore.acquire();
// 释放1个许可
semaphore.release();
~~~

#### Semaphore原理

Semaphore` 是共享锁的一种实现，它默认构造 AQS 的 `state` 值为 `permits，只有拿到许可证的线程才能执行。

要使用CAS操作修改state值，许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。

### [CountDownLatch 有什么用？]

`CountDownLatch` 允许 `count` 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。

`CountDownLatch` 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 `CountDownLatch` 使用完毕后，它不能再次被使用。

### [CountDownLatch 的原理是什么？

`CountDownLatch` 是共享锁的一种实现,它默认构造 AQS 的 `state` 值为 `count`。当线程使用 `countDown()` 方法时,其实使用了`tryReleaseShared`方法以 CAS 的操作来减少 `state`,直至 `state` 为 0 。当调用 `await()` 方法的时候，如果 `state` 不为 0，那就证明任务还没有执行完毕，`await()` 方法就会一直阻塞，也就是说 `await()` 方法之后的语句不会被执行。直到`count` 个线程调用了`countDown()`使 state 值被减为 0，或者调用`await()`的线程被中断，该线程才会从阻塞中被唤醒，`await()` 方法之后的语句得到执行。

~~~java
//应用场景，await等待阻塞的线程执行
public class CountDownLatchExample1 {
    // 处理文件的数量
    private static final int threadCount = 6;

    public static void main(String[] args) throws InterruptedException {
        // 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            final int threadnum = i;
            threadPool.execute(() -> {
                try {
                    //处理文件的业务操作
                    //......
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    //表示一个文件已经被完成
                    countDownLatch.countDown();
                }

            });
        }
        countDownLatch.await();
        threadPool.shutdown();
        System.out.println("finish");
    }
}

~~~

### CyclicBarrier 有什么用

`CyclicBarrier` 和 `CountDownLatch` 非常类似，它也可以实现线程间的技术等待，但是它的功能比 `CountDownLatch` 更加复杂和强大。主要应用场景和 `CountDownLatch` 类似。

> `CountDownLatch` 的实现是基于 AQS 的，而 `CycliBarrier` 是基于 `ReentrantLock`(`ReentrantLock` 也属于 AQS 同步器)和 `Condition` 的。

`CyclicBarrier` 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。

由一个count来计数，达到规定才放行

#### 原理

`CyclicBarrier` 默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用 `await()` 方法告诉 `CyclicBarrier` 我已经到达了屏障，然后当前线程被阻塞。

当调用 `CyclicBarrier` 对象调用 `await()` 方法时，实际上调用的是 `dowait(false, 0L)`方法。 `await()` 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 `parties` 的值时，栅栏才会打开，线程才得以通过执行

### IO流

**字节流**

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流

stream是字节流，Reader是字符流

#### InputStream

`InputStream`用于从源头（通常是文件）读取数据（字节信息）到内存中，`java.io.InputStream`抽象类是所有字节输入流的父类

`InputStream` 常用方法：

- `read()`：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 `-1` ，表示文件结束。
- `read(byte b[ ])` : 从输入流中读取一些字节存储到数组 `b` 中。如果数组 `b` 的长度为零，则不读取。如果没有可用字节读取，返回 `-1`。如果有可用字节读取，则最多读取的字节数最多等于 `b.length` ， 返回读取的字节数。这个方法等价于 `read(b, 0, b.length)`。
- `read(byte b[], int off, int len)`：在`read(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。
- `skip(long n)`：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。
- `available()`：返回输入流中可以读取的字节数。
- `close()`：关闭输入流释放相关的系统资源。

**实现的子类**

`FileInputStream` 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。

一般我们是不会直接单独使用 `FileInputStream` ，通常会配合 `BufferedInputStream`

DataInputStream` 用于读取指定类型数据，不能单独使用，必须结合其它流，比如 `FileInputStream

`ObjectInputStream` 用于从输入流中读取 Java 对象（反序列化），`ObjectOutputStream` 用于将对象写入到输出流(序列化)。

#### OutputStream

`OutputStream`用于将数据（字节信息）写入到目的地（通常是文件），`java.io.OutputStream`抽象类是所有字节输出流的父类。

`OutputStream` 常用方法：

- `write(int b)`：将特定字节写入输出流。
- `write(byte b[ ])` : 将数组`b` 写入到输出流，等价于 `write(b, 0, b.length)` 。
- `write(byte[] b, int off, int len)` : 在`write(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。
- `flush()`：刷新此输出流并强制写出所有缓冲的输出字节。
- `close()`：关闭输出流释放相关的系统资源。

`FileOutputStream` 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。

类似于 `FileInputStream`，`FileOutputStream` 通常也会配合 `BufferedOutputStream`

~~~java
FileOutputStream fileOutputStream = new FileOutputStream("output.txt");
BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)
~~~

**`DataOutputStream`** 用于写入指定类型数据，不能单独使用，必须结合其它流，比如 `FileOutputStream` 。

`ObjectOutputStream`将对象写入到输出流(`ObjectOutputStream`，序列化)。





**字符流**

字符流出现的原因

- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。
- 如果我们不知道编码类型字节流就很容易出现乱码问题。

字符流默认采用的是 `Unicode` 编码。

常用字符编码所占字节数？`utf8` :英文占 1 字节，中文占 3 字节，`unicode`：任何字符都占 2 个字节，`gbk`：英文占 1 字节，中文占 2 字节。

#### Reader

`Reader`用于从源头（通常是文件）读取数据（字符信息）到内存中，`java.io.Reader`抽象类是所有字符输入流的父类。

`Reader` 常用方法：

- `read()` : 从输入流读取一个字符。
- `read(char[] cbuf)` : 从输入流中读取一些字符，并将它们存储到字符数组 `cbuf`中，等价于 `read(cbuf, 0, cbuf.length)` 。
- `read(char[] cbuf, int off, int len)`：在`read(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。
- `skip(long n)`：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。
- `close()` : 关闭输入流并释放相关的系统资源

~~~java
// 字节流转换为字符流的桥梁
public class InputStreamReader extends Reader {
}
// 用于读取字符文件
public class FileReader extends InputStreamReader {
}
~~~

#### Writer

`Writer`用于将数据（字符信息）写入到目的地（通常是文件），`java.io.Writer`抽象类是所有字符输出流的父类。

常用方法

- `write(int c)` : 写入单个字符。
- `write(char[] cbuf)`：写入字符数组 `cbuf`，等价于`write(cbuf, 0, cbuf.length)`。
- `write(char[] cbuf, int off, int len)`：在`write(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。
- `write(String str)`：写入字符串，等价于 `write(str, 0, str.length())` 。
- `write(String str, int off, int len)`：在`write(String str)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。
- `append(CharSequence csq)`：将指定的字符序列附加到指定的 `Writer` 对象并返回该 `Writer` 对象。
- `append(char c)`：将指定的字符附加到指定的 `Writer` 对象并返回该 `Writer` 对象。
- `flush()`：刷新此输出流并强制写出所有缓冲的输出字符。
- `close()`:关闭输出流释放相关的系统资源

~~~java
// 字符流转换为字节流的桥梁
public class OutputStreamWriter extends Writer {
}
// 用于写入字符到文件
public class FileWriter extends OutputStreamWriter {
}
~~~

#### 字节缓冲流

IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，**从而避免频繁的 IO 操作，提高流的传输效率。**

字节缓冲流这里采用了装饰器模式来增强 `InputStream` 和`OutputStream`子类对象的功能。

举个例子，我们可以通过 `BufferedInputStream`（字节缓冲输入流）来增强 `FileInputStream` 的功能。

~~~java
// 新建一个 BufferedInputStream 对象
BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("input.txt"));
~~~

#### BufferedInputStream

`BufferedInputStream` 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。**就是一次性读取大量字节放在缓存区**

`BufferedInputStream` 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。缓冲区的大小默认为 **8192** 字节

#### **BufferedOutputStream**

`BufferedOutputStream` 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率。缓存区大小也是8192字节

**字符缓冲流**

`BufferedReader` （字符缓冲输入流）和 `BufferedWriter`（字符缓冲输出流）类似于 `BufferedInputStream`（字节缓冲输入流）和`BufferedOutputStream`（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。

## [打印流](#打印流)

`System.out` 实际是用于获取一个 `PrintStream` 对象，`print`方法实际调用的是 `PrintStream` 对象的 `write` 方法。属于字节打印流

### IO设计模式

**装饰器（Decorator）模式** 可以在不改变原有对象的情况下拓展其功能

~~~java
public BufferedInputStream(InputStream in) {
    this(in, DEFAULT_BUFFER_SIZE);
}

public BufferedInputStream(InputStream in, int size) {
    super(in);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
//BufferedInputStream 的构造函数其中的一个参数就是 InputStream
~~~



**适配器（Adapter Pattern）模式** 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。

#### 工厂模式和观察者模式

#### IO模型详解

计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。

![冯诺依曼体系结构](https://oss.javaguide.cn/github/javaguide/java/io/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.jpeg)

**从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。**

**先从应用程序的角度来解读一下 I/O**

为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 **用户空间（User space）** 和 **内核空间（Kernel space ）**

像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。

但用户没有这个权限，之能通过系统调用间接访问内核空间

平常开发过程中接触最多的就是 **磁盘 IO（读写文件）** 和 **网络 IO（网络请求和响应）**。

从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。

**当应用程序发起 I/O 调用后，会经历两个步骤：**

1. **内核等待 I/O 设备准备好数据**
2. **内核将数据从内核空间拷贝到用户空间。**

### 常见IO模型

IO 模型一共有 5 种：**同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

#### BIO

**BIO 属于同步阻塞 IO 模型** 。

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间

#### NIO[Non-blocking/New I/O]（IO多路复用指的是一个进程/线程可以同时监视多个文件描述符（含socket连接），一旦其中的一个或者多个文件描述符可读或者可写，该监听进程/线程能够进行IO事件的查询）

Java 中的 NIO 可以看作是 **I/O 多路复用模型**，不属于同步非阻塞IO模型

先来看看 **同步非阻塞 IO 模型**。

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

![图源：《深入拆解Tomcat & Jetty》](https://oss.javaguide.cn/p3-juejin/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.png)

这种 IO 模型同样存在问题：**应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。**

IO多路复用模型

![img](https://oss.javaguide.cn/github/javaguide/java/io/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.png)

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。

- **select 调用**：**内核提供的系统调用**，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
- **IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗**

<img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" style="zoom:67%;" />

**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

#### AIO

它是异步 IO 模型

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

<img src="https://oss.javaguide.cn/github/javaguide/java/io/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.png" alt="img" style="zoom:67%;" />

但AIO应用不多

三种IO模型总结

![BIO、NIO 和 AIO 对比](https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png)

#### NIO核心知识详解

三个核心组件

<img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" style="zoom:67%;" />

**Buffer（缓冲区）**：NIO 读写数据都是通过缓冲区进行操作的。

对通道的读操作：Channel 中的数据填充到 Buffer 中，

对通道的写操作：将 Buffer 中的数据写入到 Channel 中。

**Channel（通道）**：Channel 是一个**双向的、可读可写的数据传输通道**(不同于inputstream流单向的)，NIO 通过 Channel 来实现数据的输入输出。**通道是一个抽象的概念**，它可以代表文件、套接字或者其他数据源之间的连接。

**Selector（选择器）**：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。

在 Java 1.4 的 NIO 库中，**所有数据都是用缓冲区处理的，读写都会将数据放到缓存区再进行处理**。

Buffer差不多是一个数组，是一个内存块

~~~java
//buffer成员变量
public abstract class Buffer {
    // Invariants: mark <= position <= limit <= capacity
    private int mark = -1;//Buffer允许将位置直接定位到该标记处，这是一个可选属性
    private int position = 0;//下一个读写的位置
    private int limit;//Buffer 中可以读/写数据的边界。写模式下，limit 代表最多能写入的数据，一般等于 capacity（可以通过limit(int newLimit)方法设置）；读模式下，limit 等于 Buffer 中实际写入的数据大小。
    private int capacity;//容量，创建后不可改变
}

~~~

![position 、limit 和 capacity 之前的关系](https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png)

`Buffer` 对象不能通过 `new` 调用构造方法创建对象 ，只能通过静态方法实例化 `Buffer`。

~~~java
// 分配堆内存
public static ByteBuffer allocate(int capacity);
// 分配直接内存
public static ByteBuffer allocateDirect(int capacity);
~~~

Buffer核心方法

1. `get` : 读取缓冲区的数据

   `put` ：向缓冲区写入数据

2. `flip` ：将缓冲区从写模式切换到读模式，它会将 `limit` 的值设置为当前 `position` 的值，将 `position` 的值设置为 0。

   `clear`: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 `position` 的值设置为 0，将 `limit` 的值设置为 `capacity` 的值。

### Channel

它建立了与数据源（如文件、网络套接字等）之间的连接

![Channel 和 Buffer之间的关系](https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer.png)

Channel核心方法

1. `read` ：读取数据并写入到 Buffer 中。
2. `write` ：将 Buffer 中的数据写入到 Channel 中

#### Selector（选择器）

主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。

Channel注册后selector会监听

![Selector 选择器工作示意图](https://oss.javaguide.cn/github/javaguide/java/nio/selector-channel-selectionkey.png)

**当某个通道上发生了需要处理的事件时，选择器会通知这个I/O线程，然后该线程负责执行相应的I/O操作。由于选择器的`select()`方法是阻塞的，因此这个线程在没有就绪事件时会阻塞等待，避免了轮询的开销。**

一个 Selector 实例有三个 `SelectionKey` 集合：

1. 所有的 `SelectionKey` 集合：代表了注册在该 Selector 上的 `Channel`，这个集合可以通过 `keys()` 方法返回。
2. 被选择的 `SelectionKey` 集合：代表了所有可通过 `select()` 方法获取的、需要进行 `IO` 处理的 Channel，这个集合可以通过 `selectedKeys()` 返回。
3. 被取消的 `SelectionKey` 集合：代表了所有被取消注册关系的 `Channel`，在下一次执行 `select()` 方法时，这些 `Channel` 对应的 `SelectionKey` 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。

Selector 可以监听以下四种事件类型：

1. `SelectionKey.OP_ACCEPT`：表示通道接受连接的事件，这通常用于 `ServerSocketChannel`。
2. `SelectionKey.OP_CONNECT`：表示通道完成连接的事件，这通常用于 `SocketChannel`。
3. `SelectionKey.OP_READ`：表示通道准备好进行读取的事件，即有数据可读。
4. `SelectionKey.OP_WRITE`：表示通道准备好进行写入的事件，即可以写入数据。

## Java内存区域详解（重点）

**java的内存分配**

主要分为线程共享的堆（堆里面有字符串常量池）方法区和直接内存,线程私有的程序计数器，虚拟机栈，本地方法栈。

程序计数器主要用来记录当前线程执行的位置和依次读取字节码的指令

虚拟机栈用来存储方法的局部变量，部分结果和方法调用等信息。每个方法调用都会创建一个栈帧。

然后本地方法栈存储本地方法的信息

堆则是用来存储创建的对象实例和数组，分为年轻代和老年代，年轻代又分为 Eden 区、Survivor 区（From 和 To 区）。

方法区则是存储类的结构信息，静态变量等等，1.8之后就变为元空间了不在JVM了而是在本地内存当中了

直接内存则是用于NIO类库的



<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" style="zoom:67%;" />

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:67%;" />

堆存放的区域为主内存

### [Java 虚拟机栈](https://javaguide.cn/java/jvm/memory-area.html#java-虚拟机栈)

每个方法执行时都会创建一个栈帧，栈帧包含局部变量表、操作数栈、动态链接、方法出口等信息。

每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出

栈由一个个栈帧组成

![Java 虚拟机栈](https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png)

**局部变量表** 主要存放了编译期可知的各种数据类型、对象引用

**操作数栈** 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，**需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用**。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 **动态连接** 。

![img](https://oss.javaguide.cn/github/javaguide/jvmimage-20220331175738692.png)

不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候**，就抛出 `StackOverFlowError` 错误。**

Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。 **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束**

**程序运行中栈可能出现的错误**

- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`

### 本地方法栈

**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

### 堆

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

![堆内存结构](https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png)

**JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存**

大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置

### 方法区

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。

相当于接口和类的实现

![HotSpot 虚拟机方法区的两种实现](https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png)

**为什么用元空间 (MetaSpace) 替代永久代 (PermGen) ?**

- 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小
- 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

### [运行时常量池](https://javaguide.cn/java/jvm/memory-area.html#运行时常量池)

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table)

字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。

常量池表会在类加载后存放到方法区的运行时常量池中。

### [字符串常量池]

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.6.png" alt="method-area-jdk1.6" style="zoom:67%;" />

JDK1.7把字符串常量池移动到堆中

为什么？

**主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。**

**Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。**

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.7.png" alt="method-area-jdk1.7" style="zoom:67%;" />

### [直接内存](https://javaguide.cn/java/jvm/memory-area.html#直接内存)

在本地内存中分配

JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）\**与\**缓存区（Buffer）\**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为\**避免了在 Java 堆和 Native 堆之间来回复制数据。

## [HotSpot 虚拟机对象探秘](https://javaguide.cn/java/jvm/memory-area.html#hotspot-虚拟机对象探秘)

### 对象的创建

#### [Step1:类加载检查](#step1-类加载检查)

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用（在方法区内查找），并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### [Step2:分配内存](#step2-分配内存)

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。



**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞： 
  - 适用场合：堆内存规整（即没有内存碎片）的情况下。
  - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表： 
  - 适用场合：堆内存不规整的情况下。
  - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### [Step3:初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### [Step4:设置对象头](#step4-设置对象头)

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### [Step5:执行 init 方法](#step5-执行-init-方法)

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### [对象的内存布局](#对象的内存布局)

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，

### 对象的访问定位

目前主流的访问方式有：**使用句柄**、**直接指针**

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄" style="zoom:67%;" />

如果使用直接指针访问，reference 中存储的直接就是对象的地址

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针" style="zoom:67%;" />

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。主要用的还是直接指针访问



## JVM垃圾回收详解

### [堆空间的基本结构](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#堆空间的基本结构)

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆 内存中对象的分配与回收**

从**垃圾回收的角度**来说，由于现在收集器基本都采用分代垃圾收集算法，所以 **Java 堆被划分为了几个不同的区域。有新生代，老生代，永久代（jdk1.7后被元空间取代）**，**元空间使用的是直接内存** 。

## [内存分配和回收原则

![img](https://ask.qcloudimg.com/http-save/yehe-5539408/e63313828d55dbb0dea53e017463bdbc.png)

### [对象优先在 Eden 区分配](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#对象优先在-eden-区分配)

对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC（垃圾回收）

**年轻代被分为3个部分——Enden区和两个Survivor区,年轻代空间的要点：**

1. 大多数新建的对象都位于Eden区。
2. 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。
3. Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。
4. 经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。

### [大对象直接进入老年代]

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）

大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

- G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
- Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定

### [长期存活的对象将进入老年代]

虚拟机给每个对象一个对象年龄（Age）计数器

对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为1。

**对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁**，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中

### 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

### [空间分配担保](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#空间分配担保)

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC

### [死亡对象判断方法](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#死亡对象判断方法)

#### 引用计数法

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的

出现这样的循环引用就失效了

![对象之间循环引用](https://oss.javaguide.cn/github/javaguide/java/jvm/object-circular-reference.png)

#### 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/jvm-gc-roots.png" alt="可达性分析算法" style="zoom: 67%;" />

#### 哪些对象可以作为GC Roots

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

### 引用类型总结

![Java 引用类型总结](https://oss.javaguide.cn/github/javaguide/java/jvm/java-reference-type.png)

- 强引用：

  垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

- 软引用：

  如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存

- 弱引用：

  只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中

- 虚引用：

  如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**

### 如何判断废弃常量

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 判断无用的类

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

### 垃圾收集算法

**标记清除**

容器产生内存碎片，标记和清除两个过程效率不高

![标记-清除算法](https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-sweep-garbage-collection-algorithm.png)

**复制算法**

它可以将内存分为大小相同的两块，每次使用其中的一块。

解决了碎片化问题

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/copying-garbage-collection-algorithm.png" alt="复制算法" style="zoom:67%;" />

可用内存变小

**不适合老年代**：如果存活对象数量比较大，复制性能会变得很差

**标记整理算法**

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;" />

适合老年代这种垃圾回收频率不是很高的场景

**分代收集算法**

在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法。只需要复制一小部分对象即可完成垃圾回收

老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

#### **HotSpot 为什么要分为新生代和老年代**

主要目的是为了提高垃圾回收的效率和性能

垃圾回收策略不同

对象晋升：新生代晋升为老年代，可以减少新生代垃圾回收的频率，提高性能

空间整理：新生代的空间会经常出现碎片化。通过将新生代和老年代分开，可以更容易地对新生代进行空间整理，从而减少碎片化问题。

## 垃圾收集器

**垃圾收集器就是内存回收的具体实现**，**收集算法是内存回收的方法论**。

JDK 默认垃圾收集器

- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1

**Serial（串行收集器）**

是一个单线程收集器。它在进行垃圾收集工作的时候必须暂停其他所有的工作线程，直到它收集结束。

也就是**停顿时间**。

没有线程交互的开销，自然可以获得很高的单线程收集效率

![Serial 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/serial-garbage-collector.png)

**ParNew 收集器**

是 Serial 收集器的多线程版本

![ParNew 收集器 ](https://oss.javaguide.cn/github/javaguide/java/jvm/parnew-garbage-collector.png)

**Parallel Scavenge 收集器**

Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器

关注点是吞吐量（高效率的利用 CPU），吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量

**这是 JDK1.8 默认收集器**

![Parallel Old收集器运行示意图](https://oss.javaguide.cn/github/javaguide/java/jvm/parallel-scavenge-garbage-collector.png)

**CMS收集器**（**Concurrent Mark Sweep**）==**标记-清除”算法**

**一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用**

**是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作**

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫

![CMS 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png)

主要优点：**并发收集、低停顿**

缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**（对象之间相互引用）
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生**

JDK9之后弃用

**G1 (Garbage-First)** **收集器**

**一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征**

![G1 收集器](https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png)

特点：

**分代收集**，**并行与并发**，

**可预测的停顿**：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒

### 简述java虚拟机的垃圾回收（GC）机制。

对象的分配与内存管理

在Java程序中，对象的内存分配是由Java虚拟机自动完成的。当使用`new`关键字创建对象时，Java虚拟机会在堆内存中为该对象分配内存空间，并记录该对象的引用。同时，Java虚拟机会负责管理堆内存的分配和释放

垃圾对象识别：通过对象可达性

新生代，老年代，元空间

垃圾回收算法

- 标记清除算法
- 标记复制算法
- 标记整理算法

垃圾回收器

## 类文件结构详解

在 Java 中**，JVM 可以理解的代码就叫做`字节码`，即.class文件**

![运行在 Java 虚拟机之上的编程语言](https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png)

### 类生命周期

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:67%;" />

**加载过程**

1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存（方法区）中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。JVM可以通过它来实例对象等操作

**验证**

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全

验证阶段主要由四个检验阶段组成：

1. **文件格式验证（Class 文件格式检查）**
2. **元数据验证（字节码语义检查）**
3. **字节码验证（程序语义检查）**
4. **符号引用验证（类的正确性检查）**

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png" alt="验证阶段示意图" style="zoom:67%;" />

**准备**

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**

**解析**

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**

在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用

**初始化**

**初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)**

**类卸载**

**卸载类即该类的 Class 对象被 GC**

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 类加载器详解

- 类加载过程：**加载->连接->初始化**。
- 连接过程又可分为三步：**验证->准备->解析**

![类加载过程](https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png)

加载是类加载过程的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流

2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构

3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

   可以**实例化对象**，**获取类的信息**，**反射**，动态代理

## [类加载器](#类加载器)

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的

### 类加载器规则

- JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载，对内存更友好
- 对于一个类加载器来说，相同二进制名称的类只会被加载一次

### [类加载器总结](#类加载器总结)

JVM 中内置了三个重要的 `ClassLoader`：

1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类

也可以自定义类加载器

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:67%;" />

除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`null`的话，那么该类是通过 `BootstrapClassLoader` 加载的。

~~~java
public abstract class ClassLoader {
  ...
  // 父加载器
  private final ClassLoader parent;
  @CallerSensitive
  public final ClassLoader getParent() {
     //...
  }
  ...
}
~~~

`ClassLoader` 类有两个关键的方法：

- `protected Class loadClass(String name, boolean resolve)`：加载指定二进制名称的类，实现了双亲委派机制 。`name` 为类的二进制名称，`resolve` 如果为 true，在加载时调用 `resolveClass(Class<?> c)` 方法解析该类。
- `protected Class findClass(String name)`：根据类的二进制名称来查找类，默认实现是空方法

### 双亲委派模型

来决定类由哪一个类加载器来加载

- `ClassLoader` 类使用委托模型来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

也就是先找父加载器先来加载，如果找不到，再由自身来加载。

**并且类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。**

**组合优于继承，多用组合少用继承**

### 执行流程

- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

### 双亲模型的好处

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载。

### 想要打破这个模型

就要重写loadClass（）方法

我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制

<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构" style="zoom:67%;" />

- `CommonClassLoader`作为 `CatalinaClassLoader` 和 `SharedClassLoader` 的父加载器。`CommonClassLoader` 能加载的类都可以被 `CatalinaClassLoader` 和 `SharedClassLoader` 使用。因此，`CommonClassLoader` 是为了实现公共类库（可以被所有 Web 应用和 Tomcat 内部组件使用的类库）的共享和隔离。
- `CatalinaClassLoader` 和 `SharedClassLoader` 能加载的类则与对方相互隔离。`CatalinaClassLoader` 用于加载 Tomcat 自身的类，为了隔离 Tomcat 本身的类和 Web 应用的类。`SharedClassLoader` 作为 `WebAppClassLoader` 的父加载器，专门来加载 Web 应用之间共享的类比如 Spring、Mybatis。
- **每个 Web 应用都会创建一个单独的 `WebAppClassLoader`**，并在启动 Web 应用的线程里设置线程线程上下文类加载器为 `WebAppClassLoader`。各个 `WebAppClassLoader` 实例之间相互隔离，进而实现 Web 应用之间的类隔。

**单纯依靠自定义类加载器没办法满足某些场景的要求，例如，有些情况下，高层的类加载器需要加载低层的加载器才能加载的类**。

1. 比如，SPI 中，SPI 的接口（如 `java.sql.Driver`）是由 Java 核心库提供的，由`BootstrapClassLoader` 加载。而 SPI 的实现（如`com.mysql.cj.jdbc.Driver`）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（`BootstrapClassLoader`）也会用来加载 SPI 的实现。按照双亲委派模型，`BootstrapClassLoader` 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。
2. 再比如，假设我们的项目中有 Spring 的 jar 包，由于其是 Web 应用之间共享的，因此会由 `SharedClassLoader` 加载（Web 服务器是 Tomcat）。我们项目中有一些用到了 Spring 的业务类，比如实现了 Spring 提供的接口、用到了 Spring 提供的注解。所以，加载 Spring 的类加载器（也就是 `SharedClassLoader`）也会用来加载这些业务类。但是业务类在 Web 应用目录下，不在 `SharedClassLoader` 的加载路径下，所以 `SharedClassLoader` 无法找到业务类，也就无法加载它们

这个时候就需要用到 **线程上下文类加载器，来确保可以使用到这个需要的类**

线程线程上下文类加载器的原理是将一个类加载器保存在线程私有数据里，跟线程绑定，然后在需要的时候取出来使用。这个类加载器通常是由应用程序或者容器（如 Tomcat）设置的

`Java.lang.Thread` 中的`getContextClassLoader()`和 `setContextClassLoader(ClassLoader cl)`分别用来获取和设置线程的上下文类加载器。如果没有通过`setContextClassLoader(ClassLoader cl)`进行设置的话，线程将继承其父线程的上下文类加载器

### 数据结构的堆

堆是一种满足以下条件的树：

堆中的**每一个节点值都大于等于（或小于等于）子树中所有节点的值**。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。

注意是子树，不是整个树

**相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高**，Heap 初始化的时间复杂度为 `O(n)`,插入删除操作为O(log(n))

堆的存储可以用数组来实现（类似于完全二叉树的存储，若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 `2*i`，右子节点序号为 `2*i+1`)

### [堆的操作总结](#堆的操作总结)

- **插入元素**：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮
- **删除堆顶元素**：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化(逐一比较)，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式

## 布隆过滤器

Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true）

![位数组](https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/bloom-filter-bit-table.png)

原理介绍

**当一个元素加入布隆过滤器中的时候，会进行如下操作：**

1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。
2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。

![Bloom Filter 的简单原理示意图](https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/bloom-filter-simple-schematic-diagram.png)

**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：**

1. 对给定元素再次进行相同的哈希计算；
2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。

**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在**

### 布隆器使用场景

- 判断给定数据是否存在
- 去重：比如爬给定网址的时候对已经爬取过的 URL 去重、对巨量的 QQ 号/订单号去重

主要用于海量数据的存在性问题

### 访问修饰符

![访问修饰符图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc?x-oss-process=image/format,png)

### 常用设计模式

1. **单例模式（Singleton Pattern）**：确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂模式（Factory Pattern）**：定义一个创建对象的接口，但是让子类决定实例化哪个类。
3. **观察者模式（Observer Pattern）**：定义了一种一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新。相当于通知类型
4. **策略模式（Strategy Pattern）**：定义一系列算法，将每个算法封装起来，并使它们可以相互替换。
5. **装饰器模式（Decorator Pattern）**：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更加灵活。
6. **模板方法模式（Template Method Pattern）**：定义一个操作中的算法框架，而将一些步骤延迟到子类中。
7. **适配器模式（Adapter Pattern）**：将一个类的接口转换成客户希望的另外一个接口。
